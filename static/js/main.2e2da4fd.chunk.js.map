{"version":3,"sources":["pages/AboutPage.tsx","components/SceneComponent.tsx","utils/Freehand.ts","utils/initWebXrPolyfill.ts","utils/loadModel.ts","utils/Sculpture.ts","pages/MainPage.tsx","App.tsx","config.ts","index.tsx"],"names":["AboutPage","AboutPageDiv","styled","div","SceneComponent","props","reactCanvas","useRef","antialias","engineOptions","adaptToDeviceRatio","sceneOptions","onRender","onSceneReady","rest","useEffect","current","engine","Engine","scene","Scene","isReady","onReadyObservable","addOnce","runRenderLoop","render","resize","getEngine","window","addEventListener","dispose","removeEventListener","ref","freehandCount","Freehand","material","mesh","nextFreehand","tubeDrawOptions","tubeDrawCurrentSegment","tubeRadiuses","this","tessellation","updatable","cap","Mesh","CAP_ALL","path","Array","fill","Vector3","MeshBuilder","CreateTube","radius","meshes","push","point","FREEHAND_ALLOCATED_SEGMENTS","addFrame","Math","max","Distance","console","warn","i","name","radiusFunction","instance","initWebXrPolyfill","a","Promise","resolve","reject","navigator","xr","WebXRPolyfill","scriptElement","document","createElement","src","head","appendChild","onload","error","IMPORT_MODEL_SCALE","loadModel","filename","SceneLoader","ImportMesh","length","Error","scaling","x","y","z","position","rotation","PI","isPickable","doNotSyncBoundingInfo","Sculpture","originalMesh","originalHighpolyMesh","originalCsg","originalPosition","currentPositiveMesh","currentNegativeMesh","positiveCsg","negativeCsg","materialA","wireframeMaterial","StandardMaterial","diffuseColor","Color3","FromHexString","specularColor","alpha","wireframe","clone","positiveLowpolyMesh","isVisible","negativeHighpolyMesh","createInstance","SCULPTURE_NEGATIVE_DISTANCE","CSG","FromMesh","substractingMeshes","substractingCsg","unionInPlace","subtractInPlace","subtract","toMesh","MainPage","MainPageDiv","pointerMovePredicate","pointerDownPredicate","pointerUpPredicate","clearColor","Color4","cuttingMaterial","emissiveColor","groundMaterial","camera","FreeCamera","setTarget","Zero","canvas","getRenderingCanvas","attachControl","lightColors","split","map","c","forEach","color","light","DirectionalLight","cos","sin","intensity","diffuse","specular","ground","CreateGround","width","height","createDefaultXRExperienceAsync","floorMeshes","pointerSelection","laserPointerDefaultColor","freehand","input","onControllerAddedObservable","add","controller","all","onMeshLoadedObservable","rootMesh","onMotionControllerInitObservable","motionController","info","uniqueId","Object","keys","components","join","onButtonStateChangedObservable","state","value","absolutePosition","sculpture","App","AppDiv","element","VERSION","version","config","ConfigChecker","from","process","BUILD_DETAILS_URL","get","url","BUILD_DATE","date","toLocaleString","href","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.2e2da4fd.chunk.js","sourcesContent":["import React from 'react';\nimport styled from 'styled-components';\n\nexport function AboutPage() {\n    return (\n        <AboutPageDiv>\n            <h1>About</h1>\n        </AboutPageDiv>\n    );\n}\n\nconst AboutPageDiv = styled.div``;\n","import { Engine, EngineOptions, Scene, SceneOptions } from '@babylonjs/core';\nimport React, { useEffect, useRef } from 'react';\n\ninterface ISceneComponentProps\n    extends React.DetailedHTMLProps<\n        React.CanvasHTMLAttributes<HTMLCanvasElement>,\n        HTMLCanvasElement\n    > {\n    antialias?: boolean;\n    engineOptions?: EngineOptions;\n    adaptToDeviceRatio?: boolean;\n    sceneOptions?: SceneOptions;\n    onRender?: (scene: Scene) => void;\n    onSceneReady?: (scene: Scene) => void;\n}\n\nexport function SceneComponent(props: ISceneComponentProps) {\n    const reactCanvas = useRef(null);\n    const {\n        antialias,\n        engineOptions,\n        adaptToDeviceRatio,\n        sceneOptions,\n        onRender,\n        onSceneReady,\n        ...rest\n    } = props;\n\n    useEffect(() => {\n        if (reactCanvas.current) {\n            const engine = new Engine(\n                reactCanvas.current,\n                antialias,\n                engineOptions,\n                adaptToDeviceRatio,\n            );\n            const scene = new Scene(engine, sceneOptions);\n            if (scene.isReady()) {\n                if (onSceneReady) {\n                    onSceneReady(scene);\n                }\n            } else {\n                scene.onReadyObservable.addOnce(() => {\n                    if (onSceneReady) {\n                        onSceneReady(scene);\n                    }\n                });\n            }\n\n            engine.runRenderLoop(() => {\n                if (typeof onRender === 'function') {\n                    onRender(scene);\n                }\n                scene.render();\n            });\n\n            const resize = () => {\n                scene.getEngine().resize();\n            };\n\n            if (window) {\n                window.addEventListener('resize', resize);\n            }\n\n            return () => {\n                scene.getEngine().dispose();\n\n                if (window) {\n                    window.removeEventListener('resize', resize);\n                }\n            };\n        }\n    }, [\n        reactCanvas,\n        adaptToDeviceRatio,\n        antialias,\n        engineOptions,\n        onRender,\n        onSceneReady,\n        sceneOptions,\n    ]);\n\n    return <canvas ref={reactCanvas} {...rest} />;\n}\n","import { Material, Mesh, MeshBuilder, Scene, Vector3 } from '@babylonjs/core';\n\nconst FREEHAND_ALLOCATED_SEGMENTS = 50;\nconst RADIUS_SCALE = 0.25;\nlet freehandCount = 0;\n\nexport class Freehand {\n    public mesh: Mesh;\n    public get meshes(): Mesh[] {\n        // TODO: Sometimes tail is not disposed\n        const meshes = [this.mesh];\n        if (this.nextFreehand) {\n            meshes.push(this.nextFreehand.mesh);\n        }\n        return meshes;\n    }\n\n    private nextFreehand: Freehand | null = null;\n\n    private tubeDrawOptions: any;\n    private tubeDrawCurrentSegment = 0;\n    private tubeRadiuses: number[] = [];\n\n    public constructor(private scene: Scene, private material: Material) {\n        //console.log(this);\n        this.tubeDrawOptions = {\n            tessellation: 9,\n            updatable: true,\n            cap: Mesh.CAP_ALL,\n            path: Array(FREEHAND_ALLOCATED_SEGMENTS).fill(\n                // TODO: Some point under ground\n                new Vector3(0, 0, 0),\n            ),\n        };\n        this.mesh = MeshBuilder.CreateTube(\n            `Freehand${freehandCount++}`,\n            { radius: 0, ...this.tubeDrawOptions },\n            scene,\n        );\n\n        this.mesh.material = material;\n    }\n\n    public addFrame(point: Vector3, radius: number) {\n        if (this.tubeDrawCurrentSegment >= FREEHAND_ALLOCATED_SEGMENTS - 1) {\n            if (!this.nextFreehand) {\n                this.nextFreehand = new Freehand(this.scene, this.material);\n            }\n            this.nextFreehand.addFrame(point, radius);\n\n            if (this.tubeDrawCurrentSegment >= FREEHAND_ALLOCATED_SEGMENTS) {\n                return;\n            }\n\n            //console.warn('Freehand: Path is full, cannot add point');\n            //return;\n        }\n\n        this.tubeRadiuses[this.tubeDrawCurrentSegment] = Math.max(\n            radius,\n            this.tubeRadiuses[this.tubeDrawCurrentSegment] || 0,\n        );\n\n        const distance = Vector3.Distance(\n            point,\n            this.tubeDrawOptions.path[this.tubeDrawCurrentSegment],\n        );\n\n        if (distance < 0.01) {\n            console.warn(\n                'Freehand: Point is too close to previous point, ignoring',\n            );\n            return;\n        }\n\n        for (\n            let i = this.tubeDrawCurrentSegment++;\n            i < FREEHAND_ALLOCATED_SEGMENTS;\n            i++\n        ) {\n            this.tubeDrawOptions.path[i] = point;\n        }\n\n        this.mesh = MeshBuilder.CreateTube(this.mesh.name, {\n            radiusFunction: (i) => (this.tubeRadiuses[i] || 0) * RADIUS_SCALE,\n            instance: this.mesh,\n            ...this.tubeDrawOptions,\n        });\n    }\n}\n","export async function initWebXrPolyfill() {\n    await new Promise<void>((resolve, reject) => {\n        try {\n            if ((navigator as any).xr) {\n                return resolve();\n            }\n            if ((window as any).WebXRPolyfill) {\n                // tslint:disable-next-line:no-unused-expression\n                new (window as any).WebXRPolyfill();\n                return resolve();\n            } else {\n                const url =\n                    'https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.js';\n                const scriptElement = document.createElement('script');\n                scriptElement.src = url;\n                document.head.appendChild(scriptElement);\n                scriptElement.onload = () => {\n                    // tslint:disable-next-line:no-unused-expression\n                    new (window as any).WebXRPolyfill();\n                    resolve();\n                };\n            }\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n","import { Mesh, Scene, SceneLoader } from '@babylonjs/core';\nimport '@babylonjs/loaders/glTF';\nimport '@babylonjs/loaders/OBJ';\n\nconst IMPORT_MODEL_SCALE = 0.003;\n\nexport function loadModel(filename: string, scene: Scene): Promise<Mesh> {\n    return new Promise((resolve, reject) => {\n        SceneLoader.ImportMesh(\n            '',\n            process.env.PUBLIC_URL + 'models/',\n            filename,\n\n            scene,\n            async (meshes) => {\n                if (meshes.length === 0) {\n                    reject(new Error('No meshes found'));\n                } else {\n                    if (meshes.length > 1) {\n                        console.warn(\n                            `Found ${meshes.length} meshes, using the first one`,\n                        );\n                    }\n\n                    const mesh = meshes[0];\n\n                    mesh.scaling.x = IMPORT_MODEL_SCALE;\n                    mesh.scaling.y = IMPORT_MODEL_SCALE;\n                    mesh.scaling.z = IMPORT_MODEL_SCALE;\n                    mesh.position.x = 0;\n                    mesh.position.y = 1.2;\n                    mesh.position.z = -10;\n                    mesh.rotation.y = Math.PI;\n\n                    // Note: Optimization:\n                    mesh.isPickable = false;\n                    mesh.doNotSyncBoundingInfo = true;\n\n                    resolve(mesh as Mesh);\n                }\n            },\n        );\n    });\n}\n","import {\n    Color3,\n    CSG,\n    Mesh,\n    Scene,\n    StandardMaterial,\n    Vector3,\n} from '@babylonjs/core';\n\nexport const SCULPTURE_NEGATIVE_DISTANCE = 1.1;\n\nexport class Sculpture {\n    private originalCsg: CSG;\n    private originalPosition: Vector3;\n\n    private currentPositiveMesh: Mesh;\n    private currentNegativeMesh: Mesh | null = null;\n\n    private positiveCsg: CSG;\n    private negativeCsg: CSG | null = null;\n\n    private materialA: StandardMaterial;\n    private wireframeMaterial: StandardMaterial;\n\n    public constructor(\n        originalMesh: Mesh,\n        originalHighpolyMesh: Mesh,\n        private scene: Scene,\n    ) {\n        //-----------------------------------------\n        // TODO: Material provider\n        this.materialA = new StandardMaterial('material', scene);\n        this.materialA.diffuseColor = Color3.FromHexString('#ffffff');\n        //this.materialA.alpha = 1;\n\n        this.wireframeMaterial = new StandardMaterial('material', scene);\n        this.wireframeMaterial.diffuseColor = Color3.FromHexString('#000000');\n        this.wireframeMaterial.specularColor = Color3.FromHexString('#000000');\n        this.wireframeMaterial.alpha = 0.3;\n        this.wireframeMaterial.wireframe = true;\n        //-----------------------------------------\n        // TODO: Optimize and organize\n\n        this.currentPositiveMesh = originalMesh;\n        this.originalPosition = originalMesh.position.clone();\n\n        this.currentPositiveMesh.material = this.materialA;\n\n        const positiveLowpolyMesh = originalMesh.clone('instance');\n        positiveLowpolyMesh.material = this.wireframeMaterial;\n\n        originalHighpolyMesh.material = this.wireframeMaterial;\n        originalHighpolyMesh.isVisible = false;\n\n        const negativeHighpolyMesh =\n            originalHighpolyMesh.createInstance('instance');\n\n        originalMesh.material = this.materialA;\n        originalMesh.position.x -= SCULPTURE_NEGATIVE_DISTANCE / 2;\n        positiveLowpolyMesh.position.x -= SCULPTURE_NEGATIVE_DISTANCE / 2;\n        originalHighpolyMesh.position.x -= SCULPTURE_NEGATIVE_DISTANCE / 2;\n        negativeHighpolyMesh.position.x += SCULPTURE_NEGATIVE_DISTANCE / 2;\n\n        // TODO: CSG Clonning\n        this.originalCsg = CSG.FromMesh(originalMesh);\n        this.positiveCsg = CSG.FromMesh(originalMesh);\n    }\n\n    public subtract(...substractingMeshes: Mesh[]) {\n        try {\n            let substractingCsg: CSG | null = null;\n\n            for (const mesh of substractingMeshes) {\n                if (substractingCsg === null) {\n                    substractingCsg = CSG.FromMesh(mesh);\n                } else {\n                    substractingCsg.unionInPlace(CSG.FromMesh(mesh));\n                }\n            }\n\n            if (substractingCsg === null) {\n                throw new Error('No meshes to substract');\n            }\n\n            this.positiveCsg.subtractInPlace(substractingCsg);\n\n            // TODO: Which is faster?\n            /* [A] */\n            this.negativeCsg = this.originalCsg.subtract(this.positiveCsg);\n            /* [B] */\n            /*\n            const newPiece = this.originalCsg.intersect(substractingCsg);\n            if (this.negativeCsg === null) {\n                this.negativeCsg = newPiece;\n            } else {\n                this.negativeCsg.unionInPlace(newPiece);\n            }\n            */\n\n            this.currentPositiveMesh.dispose();\n            this.currentNegativeMesh?.dispose();\n\n            this.currentPositiveMesh = this.positiveCsg.toMesh(\n                'positive',\n                this.materialA,\n                this.scene,\n            );\n\n            this.currentNegativeMesh = this.negativeCsg.toMesh(\n                'negative',\n                this.materialA,\n                this.scene,\n            );\n\n            this.currentNegativeMesh.position = this.originalPosition.clone();\n            this.currentNegativeMesh.position.x +=\n                SCULPTURE_NEGATIVE_DISTANCE / 2;\n        } catch (error) {\n            console.error(error);\n        } finally {\n            for (const mesh of substractingMeshes) {\n                // TODO: Sometimes tail is not disposed\n                // console.log('disposing', mesh);\n                mesh.dispose();\n            }\n        }\n    }\n}\n","import {\n    AbstractMesh,\n    Color3,\n    Color4,\n    DirectionalLight,\n    FreeCamera,\n    MeshBuilder,\n    StandardMaterial,\n    Vector3,\n    WebXRAbstractMotionController,\n    WebXRInputSource,\n} from '@babylonjs/core';\nimport React from 'react';\nimport styled from 'styled-components';\nimport { SceneComponent } from '../components/SceneComponent';\nimport { Freehand } from '../utils/Freehand';\nimport { initWebXrPolyfill } from '../utils/initWebXrPolyfill';\nimport { loadModel } from '../utils/loadModel';\nimport { Sculpture } from '../utils/Sculpture';\n\nexport function MainPage() {\n    return (\n        <MainPageDiv>\n            <h1>✂️ Model splitter</h1>\n\n            <SceneComponent\n                onSceneReady={async (scene) => {\n                    // TODO: !!! Breakup into smaller functions\n\n                    await initWebXrPolyfill();\n\n                    // Note: Optimization:\n                    scene.pointerMovePredicate = () => false;\n                    scene.pointerDownPredicate = () => false;\n                    scene.pointerUpPredicate = () => false;\n\n                    scene.clearColor = Color4.FromHexString(\n                        `#1d1c21` /* Transparent + fallback to body background-color */,\n                    );\n\n                    //-----------------------------------------\n                    // TODO: Material provider\n                    const cuttingMaterial = new StandardMaterial(\n                        'material',\n                        scene,\n                    );\n                    cuttingMaterial.specularColor =\n                        Color3.FromHexString('#000000');\n                    cuttingMaterial.diffuseColor =\n                        Color3.FromHexString('#000000');\n                    cuttingMaterial.emissiveColor =\n                        Color3.FromHexString('#e41e26');\n                    cuttingMaterial.alpha = 0.9;\n\n                    const groundMaterial = new StandardMaterial(\n                        'material',\n                        scene,\n                    );\n                    groundMaterial.diffuseColor =\n                        Color3.FromHexString('#353535');\n                    groundMaterial.alpha = 1;\n                    //-----------------------------------------\n\n                    // This creates and positions a free camera (non-mesh)\n                    const camera = new FreeCamera(\n                        'camera1',\n                        new Vector3(0, 5, -10),\n                        scene,\n                    );\n\n                    // This targets the camera to scene origin\n                    camera.setTarget(Vector3.Zero());\n\n                    const canvas = scene.getEngine().getRenderingCanvas();\n\n                    // This attaches the camera to the canvas\n                    camera.attachControl(canvas, true);\n\n                    //-----------------------------------------\n                    /*/\n                    const light = new HemisphericLight(\n                        'light',\n                        new Vector3(0, 1, 0),\n                        scene,\n                    );\n                    light.intensity = 0.05;\n                    /**/\n                    //------\n                    // @see https://coolors.co/e28413-f56416-dd4b1a-ef271b-ea1744\n                    const lightColors = `4c1e4f-b5a886-fee1c7-fa7e61-f44174`\n                        .split('-')\n                        .map((c) => `#${c}`);\n                    lightColors.forEach((color, i) => {\n                        const light = new DirectionalLight(\n                            'light1',\n                            new Vector3(\n                                10 *\n                                    Math.cos(\n                                        Math.PI * 2 * (i / lightColors.length),\n                                    ),\n                                -10,\n                                10 *\n                                    Math.sin(\n                                        Math.PI * 2 * (i / lightColors.length),\n                                    ),\n                            ),\n                            scene,\n                        );\n                        light.intensity = 0.8;\n                        light.diffuse = Color3.FromHexString(color);\n                        light.specular = Color3.FromHexString(color);\n                    });\n\n                    //-----------------------------------------\n\n                    let sculpture: Sculpture;\n\n                    /*/\n                    const box = MeshBuilder.CreateBox(\n                        'box',\n                        { size: 2 },\n                        scene,\n                    );\n                    box.material = materialA;\n                    box.position.y = 1;\n                    box.position.z = -8.5;\n\n                    sculpture = new Sculpture(box, scene);\n                    /**/\n\n                    // Our built-in 'ground' shape.\n                    const ground = MeshBuilder.CreateGround(\n                        'ground',\n                        {\n                            // TODO: How to make ground infinite?\n                            width: 1000,\n                            height: 1000,\n                        },\n                        scene,\n                    );\n                    ground.material = groundMaterial;\n\n                    const xr = await scene.createDefaultXRExperienceAsync({\n                        floorMeshes: [ground],\n                    });\n\n                    xr.pointerSelection.laserPointerDefaultColor =\n                        Color3.FromHexString('#ff0000');\n\n                    let freehand: Freehand | null = null;\n\n                    xr.input.onControllerAddedObservable.add(\n                        async (controller: WebXRInputSource) => {\n                            const [rootMesh, motionController] =\n                                await Promise.all([\n                                    new Promise<AbstractMesh>((resolve) =>\n                                        controller.onMeshLoadedObservable.add(\n                                            // tslint:disable-next-line:no-shadowed-variable\n                                            (rootMesh) => resolve(rootMesh),\n                                        ),\n                                    ),\n                                    new Promise<WebXRAbstractMotionController>(\n                                        (resolve) =>\n                                            controller.onMotionControllerInitObservable.add(\n                                                // tslint:disable-next-line:no-shadowed-variable\n                                                (motionController) =>\n                                                    resolve(motionController),\n                                            ),\n                                    ),\n                                ]);\n\n                            console.info(\n                                `🕹️ ${\n                                    controller.uniqueId\n                                } connected (with ${Object.keys(\n                                    motionController.components,\n                                ).join(', ')})`,\n                                motionController,\n                            );\n\n                            /*\n                                    for (const [\n                                        key,\n                                        component,\n                                    ] of Object.entries(\n                                        motionController.components,\n                                    )) {\n                                        console.log(key, component);\n\n                                        component.onButtonStateChangedObservable.add(\n                                            (xxx) => {\n                                                console.log(xxx);\n                                            },\n                                        );\n                                    }\n                                    */\n\n                            motionController.components[\n                                'xr-standard-trigger'\n                            ].onButtonStateChangedObservable.add((state) => {\n                                if (state.value !== 0) {\n                                    if (freehand === null) {\n                                        freehand = new Freehand(\n                                            scene,\n                                            cuttingMaterial,\n                                        );\n                                    }\n\n                                    freehand.addFrame(\n                                        rootMesh.absolutePosition.clone(),\n                                        state.value,\n                                    );\n                                } else if (\n                                    state.value === 0 &&\n                                    freehand !== null\n                                ) {\n                                    sculpture.subtract(...freehand.meshes);\n\n                                    // TODO: Freeze object\n                                    freehand = null;\n                                }\n                            });\n                        },\n                    );\n\n                    // TODO: !!! Dropzone\n\n                    sculpture = new Sculpture(\n                        await loadModel(\n                            'Liver_WithTumor.lowpoly.obj',\n\n                            scene,\n                        ),\n                        await loadModel('Liver_WithTumor.obj', scene),\n                        scene,\n                    );\n                }}\n            />\n        </MainPageDiv>\n    );\n}\n\nconst MainPageDiv = styled.div`\n    h1 {\n        /*font-family: 'Times New Roman', Times, serif;\n        text-transform: uppercase;*/\n\n        color: #e41e26;\n        background-color: #fdf2f2;\n        padding: 1em;\n    }\n\n    canvas {\n        z-index: 1;\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100vw;\n        height: 100vh;\n    }\n\n    /*.controlls{\n        z-index: 1;\n        position: fixed;\n        right: 0;\n        bottom: 0;\n        width: 100vw;\n        height: 100vh;\n    }*/\n`;\n","import React from 'react';\nimport { HashRouter, Route, Routes } from 'react-router-dom';\nimport styled from 'styled-components';\nimport { AboutPage } from './pages/AboutPage';\nimport { MainPage } from './pages/MainPage';\n\nexport function App() {\n    return (\n        <AppDiv>\n            <HashRouter>\n                <Routes>\n                    <Route path=\"/\" element={<MainPage />} />\n                    <Route path=\"/about\" element={<AboutPage />} />\n                </Routes>\n            </HashRouter>\n        </AppDiv>\n    );\n}\n\nconst AppDiv = styled.div`\n    /*border: 1px dashed red;*/\n\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n`;\n","import { ConfigChecker } from 'configchecker';\n///* tslint:disable:no-var-requires */\n//const packageJson = require('../package.json');\nimport { version } from '../package.json';\n\nexport const VERSION = version;\n\nconst config = ConfigChecker.from(process.env);\n\nexport const BUILD_DETAILS_URL = config\n    .get(\n        'REACT_APP_BUILD_DETAILS_URL' /* TODO: configchecker can ignore prefxes in ConfigChecker.from */,\n    )\n    .url().value;\n\nexport const BUILD_DATE = config\n    .get(\n        'REACT_APP_BUILD_DATE' /* TODO: configchecker can ignore prefxes in ConfigChecker.from */,\n    )\n    .date().value;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\nimport { BUILD_DATE, BUILD_DETAILS_URL, VERSION } from './config';\n\nconsole.info(\n    `%c✂️ Model splitter version ${VERSION}` +\n        (!BUILD_DATE ? `` : `\\nBuild at ${BUILD_DATE.toLocaleString()}`) +\n        (!BUILD_DETAILS_URL\n            ? ``\n            : `\\nView build details ${BUILD_DETAILS_URL.href}`),\n    `background: #009EDD; color: white; font-size: 1.1em; font-weight: bold; padding: 5px; border-radius: 3px;`,\n);\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n"],"sourceRoot":""}